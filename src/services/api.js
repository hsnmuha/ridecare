import { supabase } from '../supabaseClient';
import { generateId } from '../utils/logic';

// --- MOTORS ---

export const fetchMotors = async () => {
    const { data, error } = await supabase
        .from('motors')
        .select('*')
        .order('created_at', { ascending: false });

    if (error) throw error;
    return data;
};

export const fetchMotorById = async (id) => {
    const { data, error } = await supabase
        .from('motors')
        .select('*')
        .eq('motor_id', id) // Warning: Schema uses 'id' as primary key UUID, but code might expect 'motor_id'. 
        // Let's check schema again. Schema has 'id' as PK, but previous code used 'motor_id'. 
        // We might need to map or strictly use 'id'. 
        // Schema: id uuid default gen_random_uuid() primary key.
        // The previous code generated 'motor_id' manually. 
        // Strategy: Use Supabase 'id' as the truth.
        .single();

    if (error) throw error;
    return data;
};

// However, the existing code uses `motor_id` heavily. 
// Let's check schema again. 
// "create table public.motors ( id uuid default gen_random_uuid() primary key, ... )"
// The ID generated by Supabase is 'id'. 
// To minimize refactor, I should probably map the Supabase 'id' to 'motor_id' in the frontend, OR update the frontend to use 'id'.
// Updating frontend to use 'id' is cleaner.
// But wait, the previous code generated 'motor_id' manually: `motor_id: generateId(),`.
// If I use Supabase, I should let Supabase generate the ID usually, OR I can provide it if the column allows.
// The schema says `id uuid default gen_random_uuid()`. 
// I will use the `id` from Supabase.

export const addMotor = async (motorData) => {
    // Remove motor_id if it's being generated manually, let Supabase handle ID or key
    // Actually, for better sync, letting the client generate UUID is fine if it matches UUID format, 
    // but the `generateId` in utils/logic.js uses `Date.now().toString(36)...` which is NOT a valid UUID.
    // Supabase expects UUID for the 'id' column.
    // So we MUST omit 'id' and let Supabase generate it, OR generate a valid UUID.
    // I will let Supabase generate it.

    const { nama_motor, merek, model, tahun, no_polisi, odometer_awal } = motorData;

    // Insert Motor
    const { data, error } = await supabase
        .from('motors')
        .insert([
            { nama_motor, merek, model, tahun, no_polisi }
        ])
        .select()
        .single();

    if (error) throw error;

    // We also need to add the initial odometer reading
    if (odometer_awal) {
        await addOdometer({
            motor_id: data.id,
            nilai_odometer: odometer_awal,
            tanggal_catat: new Date()
        });
    }

    return data;
};

export const updateMotor = async (id, updates) => {
    const { data, error } = await supabase
        .from('motors')
        .update(updates)
        .eq('id', id)
        .select();

    if (error) throw error;
    return data;
};

export const deleteMotor = async (id) => {
    const { error } = await supabase
        .from('motors')
        .delete()
        .eq('id', id);

    if (error) throw error;
};

// --- SERVICES ---

export const fetchServices = async (motorId) => {
    const { data, error } = await supabase
        .from('services')
        .select('*')
        .eq('motor_id', motorId)
        .order('tanggal_perawatan', { ascending: false });

    if (error) throw error;
    return data;
};

export const addService = async (serviceData) => {
    // Expects: motor_id, jenis_perawatan, tanggal_perawatan, odometer_saat_ganti, biaya, nama_bengkel, detail_spesifik, receipt_url, jadwal_berikutnya_km, jadwal_berikutnya_tanggal

    // Receipt upload should be handled before calling this, or passed as url
    const { data, error } = await supabase
        .from('services')
        .insert([serviceData])
        .select()
        .single();

    if (error) throw error;

    return data;
};

// --- ODOMETERS ---

export const fetchOdometers = async (motorId) => {
    const { data, error } = await supabase
        .from('odometers')
        .select('*')
        .eq('motor_id', motorId)
        .order('tanggal_catat', { ascending: false });

    if (error) throw error;
    return data;
};

export const addOdometer = async (odoData) => {
    const { motor_id, nilai_odometer, tanggal_catat } = odoData;

    const { data, error } = await supabase
        .from('odometers')
        .insert([
            { motor_id, nilai_odometer, tanggal_catat }
        ])
        .select()
        .single();

    if (error) throw error;
    return data;
};

// --- STORAGE ---

export const uploadReceipt = async (file) => {
    if (!file) return null;

    const fileExt = file.name.split('.').pop();
    const fileName = `${Math.random()}.${fileExt}`;
    const filePath = `${fileName}`;

    const { data, error } = await supabase.storage
        .from('receipts')
        .upload(filePath, file);

    if (error) throw error;

    // Get public URL
    const { data: { publicUrl } } = supabase.storage
        .from('receipts')
        .getPublicUrl(filePath);

    return publicUrl;
};
